Adding a "sample" task should be fairly straightforward, although
routing the SIGALRM signals might be nontrival (and do we really
want to implement an alarm scheduler?).  The obvious use is
accumulators that roll over often, e.g., PKG_ENERGY_STATUS.
Wouldn't mind having SAMPLE:control_cpu:sampled_cpus:msr:interval_ms
Sampling as its own task hierarchy

Put in a silly "printf the version" function and use it for both
--help and --version.

Revisit how we handle input errors (e.g., the ':' case doesn't
give a helpful message).

print_cpuset() should really be cpuset2str().

Eventually add seperate builds for release, debug,
sanitize=address and sanitize=thread

cpuset checks don't check to see if the cpu physically exists.
Parse /sys/devices/system/cpu?

Add scrub_batch() to remove error codes (makes them reusable).

Longitudinal:  CAPFREQUENCY

Longitudinal:  COLDSTART

Longitudinal:  ZEROAMPERF

Make address and thread sanitizing useful.
https://stackoverflow.com/questions/77850769/fatal-threadsanitizer-unexpected-memory-mapping-when-running-on-linux-kernels

Remove SLEEP

--dry-run

clean up makefile

Write values that are potentially >32 bits as two separate 32-bit fields
(gets around R limitation)

If 0xdecafbad is in the error field, don't print the sample.

Really need WAIT_UNTIL:msr:relation:value:mask:seconds

Summary statistics

Add PLATFORM_ENERGY to polling

Replace asserts with intelligible error messages.

Verify we can handle large CPU counts.

